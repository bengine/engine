#include "base64_private.h"

static base64_char_t encode_table_[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

static base64_char_t decode_table_[] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF, 0xFF, 0x3F,
	0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B,
	0x3C, 0x3D, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF,
	0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
	0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
	0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,
	0x17, 0x18, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20,
	0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
	0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30,
	0x31, 0x32, 0x33, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

static base64_char_t placeholder_ = '=';

static base64_char_t encode_(base64_char_t byte) {
	return encode_table_[byte];
}

static base64_char_t decode_(base64_char_t byte) {
	return decode_table_[byte];
}

void base64_encode1(base64_char_t *dest, const base64_char_t *src) {
	dest[0] = encode_((src[0] >> 2) & 0x3F);
	dest[1] = encode_(((src[0] << 4) & 0x30));
	dest[2] = placeholder_;
	dest[3] = placeholder_;
}

void base64_encode2(base64_char_t *dest, const base64_char_t *src) {
	dest[0] = encode_((src[0] >> 2) & 0x3F);
	dest[1] = encode_(((src[0] << 4) & 0x30) | ((src[1] >> 4) & 0x0F));
	dest[2] = encode_(((src[1] << 2) & 0x3C));
	dest[3] = placeholder_;
}

void base64_encode3(base64_char_t *dest, const base64_char_t *src) {
	dest[0] = encode_((src[0] >> 2) & 0x3F);
	dest[1] = encode_(((src[0] << 4) & 0x30) | ((src[1] >> 4) & 0x0F));
	dest[2] = encode_(((src[1] << 2) & 0x3C) | ((src[2] >> 6) & 0x03));
	dest[3] = encode_(src[2] & 0x3F);
}

size_t base64_encode(base64_char_t *output, const base64_char_t *input, size_t input_len) {
	size_t floor = (input_len / 3) * 3;
	size_t len = input_len - floor;
	base64_char_t *optr = output;
	const base64_char_t *ptr, *end = input + floor;

	/* encode complete triplet */
	for (ptr = input; ptr < end; ptr += 3) {
		base64_encode3(optr, ptr);
		optr += 4;
	}

	/* encodes a 2-byte ending into 3 bytes and 1 pad byte and writes */
	if (len == 2) {
		base64_encode2(optr, ptr);
		optr += 4;
		return optr - output;
	}

	/* encodes a 1-byte ending into 2 bytes and 2 pad bytes */
	if (len == 1) {
		base64_encode1(optr, ptr);
		optr += 4;
		return optr - output;
	}

	return optr - output;
}

size_t base64_decode3(base64_char_t *dest, const base64_char_t *src) {
	base64_char_t b0 = decode_(src[0]);
	base64_char_t b1 = decode_(src[1]);
	base64_char_t b2 = decode_(src[2]);
	base64_char_t b3 = decode_(src[3]);

	/* make sure all characters were valid */
	if (b0 == 0xFF || b1 == 0xFF || b2 == 0xFF || b3 == 0xFF)
		return 0;

	/* decode and return the number of bytes actually decoded */
	dest[0] = ((b0 << 2) & 0xFC) | ((b1 >> 4) & 0x03);
	if (src[2] == placeholder_)
		return 1;

	dest[1] = ((b1 << 4) & 0xF0) | ((b2 >> 2) & 0x0F);
	if (src[3] == placeholder_)
		return 2;

	dest[2] = ((b2 << 6) & 0xC0) | ((b3 >> 0) & 0x3F);
	return 3;
}

size_t base64_decode(base64_char_t *output, const base64_char_t *input, size_t input_len) {
	const base64_char_t *end = input + input_len;
	base64_char_t *optr = output;
	const base64_char_t *ptr;

	/* decode complete triplet */
	for (ptr = input; ptr < end; ptr += 4)
		optr += base64_decode3(optr, ptr);
	return optr - output;
}
